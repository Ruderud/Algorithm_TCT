# 2021-04-14


import time
'''
start = time.time()

def fibo(n):
    if n==1 or n==2:
        return 1
    return fibo(n-1)+fibo(n-2)

print(fibo(35))

end = time.time()
print(end-start)
'''

#위는 간단한 피보나치를 구하는 재귀식으로써, 저렇게하면 처음몇까지는 금방나오지만, 35번째부터는 1초이상걸린다. (대충 갈수록 기하급수적으로 비효율적이라는내용)
#이러한 문제를 해결하려면 다이나믹 프로그래밍(여기서는 메모니제이션)을 사용한다.
#해당 방법을 적용하기 위한 조건은 1) 큰문제를 작은 문제로 나눌수 있을때 & 2)작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일할 것.

#메모니제이션=캐싱 : 값을 저장하는방법. 단순하게말하면 그냥 계산결과를 저장해서 불러오는것이다. -> 시간복잡도 O(N)

'''
start = time.time()
d = [0] * 100

def fibo_m(x):
    if x==1 or x==2:
        return 1
    if d[x] != 0:
        return d[x]
    d[x] = fibo_m(x-1)+fibo_m(x-2)
    return d[x]

print(fibo_m(35))
end = time.time()
print(end-start)        #비교해보면 위는 1.28초가 걸리지만, 아래는 3.03e-05라는 엄청난 차이가 난다.
'''

#이 방법을 Top-Down방식(=하향식)이라고한다. (큰문제를 해결하기위해 작은문제를 호출-해결해나감)
#반대로 단순 반복문을 이용하여 해결하는방법은 Bottom-Up(=상향식)이라고 한다. (아래의방법)

'''상향식->1부터 하나씩 해나가면서 100까지 도달한다. 
d=[0]*100

d[1]=1
d[2]=1
n=99

for i in range(3,n+1):
    d[i]=d[i-1]+d[i-2]

print(d[n])
'''

#되도록 바텀업을 위주로 구현하자. 탑다운방법은 스택크기가 한정되어있을때는 제한적이다.
#물론 이 스텍문제도 sys라이브러리에서 setrecursionlimit()함수를 이용하여 재귀제한을 완화시킬수있다.


#실전문제2 1로 만들기 (time over)
'''
흠... 일단 모두나눌수있을때는 5>3>2>-1순서로 중요하긴함.

하지만 85의 경우에는 -4후 81로 나눠서 8번사용 vs 85->17->-2->3->1
그냥 최대한 큰걸로 나누는게 이득??
'''

'''
x = int(input())

d = [0] * 30001

for i in range(2,x+1):
    d[i] = d[i-1] + 1 #현재의 수에서 1을 빼는경우    d[2]=0는 d[1]=0에서 1을 더해서 만든다. // d[3]=2를 먼저 만든다.(A)

    if i%2==0:  #현재의 수가 각각 2,3,5로 나누어떨어질때
        d[i] = min(d[i],d[i//2]+1)  #i=2일때 d[2]=1, (d[1]=0)+1 = 1이으로 1이된다. 4일때
    if i%3==0:
        d[i] = min(d[i],d[i//3]+1)  #(A)에서 만든 d[3]가 3으로 나누었을때 나누어떨어지고, 
                                    #이때 d[1]=0에 횟수 1번을 추가한것과 같기때문에 둘중 최소값인 1이 d[3]로 고쳐지게된다.
                                    #이러한 방법으로 2,3,5의 배수에대해서는 최소화가 이루어지면서 bottom-up이 이루어짐.
    if i%5==0:
        d[i] = min(d[i],d[i//5]+1)

print(d[x])
'''



#실전문제3 개미 전사
'''
창고 갯수는 100개 -> bottom up?
1,3,5...99번째까지 1개씩 텀을두고 털었을때의 총합
마지막 ...97 99 or ...97 100일때의 총합비교
95 98 100의 값. 이렇게 끝에꺼를 하나씩 밀어가면서 다더해보면서 그중 최대값을 출력하게끔해볼까?

근데 그러면 조합수가... 드럽게많다... 각각을 리스트에 추가하는식으로 가능할까?

ㄴㄴ 그냥 베이직하게 1,3,5...97, 99를 베이직으로 하고, 이값을 저장해놓은다음, 이거보다 클때만 교체하는방식으로 비교해나가는건 어떤가

1,2,3,4,5,6이 있을때
(자리기준) 1+3+5(basic)을 구하고, 1+3+6와 비교해서 큰거 저장. 
1 4 6 비교
2 4 6 비교
2 5 비교
3 5 비교
3 6비교
4 6비교...
'''


'''풀이
"""
일단 이건 앞에서부터 계산해나가는 점화식꼴이라는걸 받아들어야함.

array 1  3  1  5  9  2

      0  1  2  3  4  5

d     1  3  3  8  12 12

d[0],d[1]값은 이견없이 정해져있다.

d[i]는 ( d[i-2] + array[i] ) Vs d[i-1] 중, 큰것을 가져온다.
이는 가장 효율적인 선택이되므로, i-3이전에 대해서는 고려할 필요가없다.

그렇기에 각 자리까지의 합산값을 d에 저장하는 bottom-up방식을 이용하여 구할 수 있다.
"""

n=int(input())
array = list(map(int,input().split()))

d = [0] * 100

d[0] = array[0]
d[1] = max(array[0],array[1])
for i in range(2,n):
    d[i] = max(d[i-1],d[i-2]+array[i])

print(d)
'''

#실전문제4 바닥 공사(time over)
'''
세로는 항상 2, 가로가 n으로 가변.
1자를 이용한것은 항상 존재
1x+2y꼴로 n을 표현하면되지않냐
n=3일때, (3,0), (1,1)
1,1일때 x y // y x 순도 있고, 각각에 따라 y는 1x2 2개일때, 2x2일때의 조합수를 또 곱해줘야함.

n=3 ->1+(2*2)
n=4 ->1+1+(2*2)
'''

'''점화식을 이해해야한다.
f(n)=f(n-1)*1
->f(n-1)은 뭐 어케 구했다 '치고' 세로 타일 하나를 붙일수 있는방법은 n-1의 조합에 맨뒤에 세로타일을 붙이는 한가지방법뿐이다.
f(n)=f(n-2)*2
->f(n-2)도 구했다 '치고' 가로2짜리 타일을 붙일 수 있는 방법은 n-2의 조합의 뒤에 1x2짜리 2개 또는 2x2짜리 1개를 붙이는 방법 2가지뿐이다.
따라서 3가지 타일을 사용한 f(n)의 방법은 f(n-1) + 2*f(n-2) 이다. 
(+f(n-3)에 대해서 고려할 필요는 없다. 왜냐면 이미 가로 3칸짜리를 붙이는것은 위의 조합으로 나타낼 수 있기때문이다.)

n=int(input())

d = [0] * 1001

d[1]=1
d[2]=3
for i in range(3,n+1):
        d[i] = (d[i-1] + (d[i-2]*2))%796796

print(d[n])
'''

#실전문제5 효율적인 화폐 구성 (발상과 구현둘다 쉽지않다)
'''

2기준 에서 d[18]은 9이다.
3기준에서 d[18]은 6이다. 공배수
3기준 d[16]은 d[13]+1 = d[10]+2 =d[7]+3 = d[4] +4 = d[1] +5  .......아직까지 d[1]은 -1의 값을 가지므로 1
-> 아 여기문제때문에 m이 1~10000까지일때 바로 -1을 할당하고 만들수있는걸 추가하는게 아니라, 최대값 10001을 박고 가져왔네
그러면 뒤에서부터 10006, 6, 10004, 7이 되니까 최소값인 6을 값으로 하게된다.

'''


n,m = map(int,input().split())

array=[]
for i in range(n):
    array.append(int(input()))

d = [10001] * (m+1)     #default값을 10001로 잡고, 목표값+1개만큼(index고려) 리스트 원소를만든다. 이유는 후술

array.sort() #굳이 정렬할 필요는없다

d[0] = 0                #합0을 만들기위해서는 숫자를 하나도 사용하지 않아야하므로, 0이된다.
for i in range(n):      #array숫자를 하나씩 가져와서 수행한다.
    for j in range(array[i],m+1): #첫 시행은 array의 첫숫자부터 시작한다. (0번쨰는 이미 정의했으니까). 
                                  #for문을 쓰는이유는 배수를 리스트값에 추가하는게 목적이 아니라, d리스트 값 중, array[i]값을 '1회'씩 추가해서 만들수있는지 여부과 그 횟수를 기록하기 위함임.

        if d[j - array[i]] != 10001: #(처음)d[0]을 의미하는데 이는 10001이 아니다.(A-1)
            d[j] = min(d[j], d[j-array[i]]+1)  #그렇기에 첫시행값은 d[2]=10001 과 d[0]+1회중 '작은(횟)수'를 값으로 지정한다.(A-2) 이때 +1은 '횟수'를 의미한다.
                                               #이때 최소값을 구하는것이 계산목표이기때문에 처음부터 -1을 배정하면 무조건 -1만 나와서 계산진행이 안된다.
                                               #그래서 더 큰값이 나올수없는 10001을 default값으로 배정한것.
                                               #이후 d[4]는 10001 vs d[2] + 1'회' =2 중 작은값인 2가되는 방식으로 데이터 저장.

                                               #array값이 다음순서로 넘어가도 위와 같다. 다만, 횟수를 더했을때 중복되는 값은 최소값을 저장한다.(이는 위의 메모내용 확인)

                                               #(첫값2기준) 이외의 3,5,7 등 10001이 나오면 그냥 패스한다. 

print(d[m]) #m값을 만드는데 사용한 숫자횟수 최소값을 출력한다.




